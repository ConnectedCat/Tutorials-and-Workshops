<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to THREE.JS</title>
    <style>
        code, code pre {
            background-color: #3e3e3e;
            color: antiquewhite;
        }

        img {
            max-width: 500px;
        }
    </style>
</head>
<body>
    <h1>Introduction to THREE.JS</h1>
    <h3>Useful links:</h3>
    <ul>
        <li><a href="https://threejs.org/" target="_blank" rel="noopener noreferrer">THREE.JS Website</a></li>
        <li><a href="https://threejs.org/docs/index.html#manual/en/introduction/Installation" target="_blank" rel="noopener noreferrer">THREE.JS Documentation</a></li>
        <li><a href="https://vitejs.dev/" target="_blank" rel="noopener noreferrer">Vite</a></li>
        <li><a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer">Node.JS</a></li>
        <li><a href="https://lil-gui.georgealways.com/" target="_blank" rel="noopener noreferrer">lil-gui</a></li>
    </ul>

    <h2>Example 1: Starter project</h2>
    <p>We will create a basic example showing how a THREE.JS app is initiated, fundamental structure and some useful UI add-one.</p>
    <p>The result should resemble </p>
    <ol>
        <li>
            <p>Start by launching your Terminal (PowerShell on Windows.) Once it's running type in the command:</p>
            <code>node --version</code>
            <p>If you see a version number and it's higher than 14.0.0 - you'll be fine. If you get a response that amounts to "I don't know what you want from me!" you'll need to install NodeJS from their website: <a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer">nodejs.org</a>. Grab the version recommended for the most users and proceed with the installation. Once it's finished it might not be a bad idea to restart your machine - just to make sure all the paths are updated. After that try launching Terminal (PowerShell on Windows) and running the command again.</p>
            <code>node --version</code>
            <p>You should see the version number now. Also run this command:</p>
            <code>npm --version</code>
            <p>You should see a number higher than 6.0.0 If you don't - consult this guide for details <a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm" target="_blank" rel="noopener noreferrer">"Downloading and installing Node.js and npm"</a></p>
            <p>If you think of a browser as a car NodeJS is the engine from that car, that has been extracted and packaged and can be installed in your garage (on your computer) to provide power to your tools. NPM is Node Package Manager, and it will help us manage and install new components for that engine. You ternimal (or PowerShell on Windows) should look something like this now:</p>
            <img src="../The_WWW_as_a_Rube_Goldberg_machine/img/terminal1.png" alt="Terminal view with Node and NPM version commands">
        </li>
        <li>
            <p>We'll need to create a simple Node-based Web application and run it in a local server to make sure that the requests to OpenAI API come from an HTTP host and not just a file in your filesystem. There are many ways of doing this - one of the simpler ones is to create an app with <a href="https://vitejs.dev/guide/#scaffolding-your-first-vite-project" target="_blank" rel="noopener noreferrer">Vite</a>, a scaffolding engine.</p>
            <p>Before we create our app let's figure out where will we be building it. To find your current working directory run</p>
            <code>pwd</code>
            <p>command in your Terminal (or PowerShell on Windows.) This will print out the path. From there you can navigate to the directory where you'd like to build your app. For example, I prefer to keep my coding projects in the "Repositories" directory inside my user folder so to move there from my current personal user folder I will run a cd (change directory) command like this:</p>
            <code>cd Repositories</code>
            <p>Once there I will run a simple command to create a Vite-based web-app:</p>
            <code>npm create vite@latest</code>
            <p>and follow the prompts. I will name my project "openAIapiProject" and we'll be using vanilla JavaScript for this project. So my terminal will look like this:</p>
            <img src="img/Terminal1.png" alt="Terminal view after the creation of a Vite template"/>
        </li>
        <li>
            <p>Once you've created your web-app Vite will prompt you with 3 next steps: change to the newly created app directory (its name is the same as the name you gave your Vite project), install the packages necessary to run your app and then run it in a developer mode. After completing the first 2 steps your Terminal (or PowerShell) would look similar to this:</p>
            <img src="img/Terminal2.png" alt="Terminal view showing Vite instructions 1 and 2">
            <p>Now you should be ready to run your app. Run the third command (npm run dev) and your NodeJS server should start. If you press "h" for help you should be able to see this:</p>
            <img src="../The_WWW_as_a_Rube_Goldberg_machine/img/terminal4.png" alt="Terminal view showing running Vite server">
            <p>You can press 'o' to open the default page in your browser. Vite server will track any chages you make to your web-app and will restart this browser page the moment you save your changes to your file, which is neat. So check back here as you progress with your work.</p>
        </li>
        <li>
            <p>Open the directory that Vite has created for your web-app in your code editor and you'll see that there are a lot of things there that we won't need. You can start deleting them</p>
            <img src="../The_WWW_as_a_Rube_Goldberg_machine/img/ViteCleanup.png" alt="File structure view showing what to delete in Vite: public folder, counter.js and javascript.svg">
            <p>You can also remove evrything from "style.css" and leave only one line in main.js, the first one:</p>
            <code>
                import './style.css'
            </code>
            <p>In your CSS file (style.css) select and delete all the content and add this line</p>
            <code>
                html, body { margin: 0; }
            </code>
            <p>They will simply make sure that the content of your page is flush with your browser window.</p>
            <p>Save all your changes and check back with your browser - you should see a blank page instead of the default page you saw before. You can check on the resulting file structure <a href="" target="_blank" rel="noopener noreferrer">here</a>. The last thing we need to do in your Terminal is to instal Three.JS library for NodeJS. In your Terminal press 'q' to quit your Vite server and run</p>
            <code>npm install three</code>
            <p>Once the installation has finished you can run</p>
            <code>npm run dev</code>
            <p>again to restart the Vite server.</p>
        </li>
        <li>
            <p>Next we'll need to import the Three.JS module into our main.js file, we can do that right after the CSS import</p>
            <code>
                <pre>
import './style.css'
import * as THREE from 'three'    
                </pre>
            </code>
            <p>With that we'll have access to all the components of the standard ThreeJS library. There are some additinal component that we will need to import, but they are already installed in out app folder (in the node_modules section).</p>
            <p>With this we can implement the most basic scene in ThreeJS. We'll start by steeting up a data object for our window sizes - not strictly necessary, but it will come handy later. Then we'll create a scene and a camera and position the camera a bit up and a bit closer to us. Lastly we'll need to create a renderer that will render the graphics for us and append it to the HTML document.</p>
            <code>
                <pre>
//scene size
const sizes = {
    width: window.innerWidth,
    height: window.innerHeight
}

//scene
const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera( 75, sizes.width / sizes.height, 0.1, 1000 )
camera.position.z = 5
camera.position.y = 2

//renderer
const renderer = new THREE.WebGLRenderer()
renderer.setSize( sizes.width, sizes.height )
document.body.appendChild( renderer.domElement )
                </pre>
            </code>
            <p>After this we can add some contents to our scene and render it. We'll add a cube - this will require a box geometry and we'll start wil a Basic material, although we'll switch to Standard material very soon. The geometry and the material will allow us to create a mesh which we'll add to our scene. The last step here will be to render our scene as seen through our camera.</p>
            <code>
                <pre>
//scene contents
const cubeGeometry = new THREE.BoxGeometry( 1, 1, 1 )
const cubeMaterial = new THREE.MeshBasicMaterial( { color: 0x48727f } )
const cube = new THREE.Mesh( cubeGeometry, cubeMaterial )
cube.position.y = 1

scene.add( cube )

renderer.render( scene, camera )                    
                </pre>
            </code>
        </li>
        <li>
            <p>Let's add animation to our scene. We'll use a standard JavaScript animation technique which involves creating a function that will instruduce changes to our scene and then call itself again, thus repeating those changes. Just make sure to re-render the scene each time, so those increamental changes are visible. You can repace the renderer.render call with the following:</p>
            <code>
                <pre>
//animation
function draw() {
    requestAnimationFrame( draw )

    cube.rotation.x += 0.01
    cube.rotation.y += 0.01

    renderer.render( scene, camera )
}
draw()                    
                </pre>
            </code>
            <p>Let's also add a bit of housekeeping. Right now if you resize your window the scene will remain whichever size it had when the window loaded. We can make it change the size to follow the size of the browser window. To do that we'll use the sizes data object we created earlier, and call updates on it every time the window is resized. This code can go at the end of your main.js file:</p>
            <code>
                <pre>
window.addEventListener('resize', ()=>{
    console.debug("resize")
    // Update sizes
    sizes.width = window.innerWidth
    sizes.height = window.innerHeight

    // Update camera aspect ratio
    camera.aspect = sizes.width / sizes.height
    camera.updateProjectionMatrix()

    // Update the renderer
    renderer.setSize(sizes.width, sizes.height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
})
                </pre>
            </code>
        </li>
        <li>
            <p>You'll notice that the cube looks 2-dimensional and has no shadows. This is because we are using Basic Material and because there are no lights to give it dimensionality. Let's change that. We'll start by changing the material to MeshStandardMaterial:</p>
            <code>
                const cubeMaterial = new THREE.MeshStandardMaterial( { color: 0x48727f } )
            </code>
            <p>Then we can add some lights to the scene. We can put the code for lights anywhere, but I prefer to keep them near the general scene settings, near the camera and the renderer. We'll add two lights - an ambient light to simulate daylight, and a directional light to serve as an intentional source of light. The directional light will be places above and to the right.</p>
            <code>
                <pre>
const ambientLight = new THREE.AmbientLight( 0x404040 ) // soft white light
scene.add( ambientLight )

const directionalLight = new THREE.DirectionalLight( 0xFFFFFF )
directionalLight.position.set( 4, 8, 0 )
scene.add( directionalLight )                    
                </pre>
            </code>
        </li>
    </ol>
    <h2>Example 2: UI options</h2>
    <p>The previous code should give you a basic starter scene from which you can build further but it lacks certain UI options that will make a 3D environment comfortable. We'll add the ability to move around the scene and control parameters of the objects and the environment to make interactions easier. We'll also add helpers to make it easier to visualise the positions of the scene elements.</p>
    <ol>
        <li>
            <p>We'll start by adding Orbit Controlls to allow us to move around the scene. To do that we'll need to import an add-on from the ThreeJS library, set up the controls and make sure the changes are displayed during the animation rendering.</p>
            <p>Start by adding the following line after the import declaration for ThreeJS itself.</p>
            <code>
                import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
            </code>
            <p>Then we can instantiate the controlls. We can put this code anywhere, but I prefer to keep them near the general scene settings, near the camera and the renderer.</p>
            <code>
                const controls = new OrbitControls( camera, renderer.domElement )
            </code>
            <p>Then we will update the controlls to make sure the changes are reflected in the animation render. You can put this line after the cube rotation updates in the draw() function.</p>
            <code>
                controls.update()
            </code>
        </li>
        <li>
            <p>With the cube alone it is a little difficult to understand how the controls work, especially since the cube is positioned slightly above the scene center. We can help that by adding a 'floor' and an axisHelper - a set of three lines indication the orientation of the scene. For the floor we'll use plane and add it right after the cube. We'll need to rotate it to make it face up.</p>
            <code>
                <pre>
const plane = new THREE.Mesh( new THREE.PlaneGeometry( 7, 5 ), new THREE.MeshStandardMaterial( { color: 0xf5ff9d, side: THREE.DoubleSide } ) )
plane.rotation.set( -Math.PI * 0.5, 0, 0 )   

scene.add( plane )                
                </pre>
            </code>
            <p>The helper we can add near the Orbit Controls instantiation, but anywhere after the scene instantiation is fine, because we need to add it as an element to the scene:</p>
            <code>
                <pre>
const axesHelper = new THREE.AxesHelper( 5 )
scene.add( axesHelper )
                </pre>
            </code>
            <p>We can also add a light helper to help us visualise how the light is positioned and directed. You can add the following code with the lights or with the helpers - but try to find a logic to the way you organize your code.</p>
            <code>
                <pre>
const directionalLightHelper = new THREE.DirectionalLightHelper( directionalLight, 5 )
scene.add( directionalLightHelper )
                </pre>
            </code>
            <p>This should make it easy to understand how the scene is set-up and we can remove the elements once we're done with the build.</p>
        </li>
        <li>
            <p>During the build and experimentation it can be helpful to give yourself a quick way to tweak parameters, and we can do that with a simple pre-built GUI package. We'll need to install it with npm first, then import it to the file and then implement it. Start by switching to your terminal and quitting the Vite server by pressing 'q'. Then run 'npm install lil-gui' and restart your server when the installation is done with 'npm run dev'.</p>
            <img src="img/Terminal3.png" alt="lil-gui installation process">
            <p>To import it into your scene add the following after your Orbit Controls import:</p>
            <code>
                import GUI from 'lil-gui'
            </code>
            <p>We can then add instantiation for the gui object. I tend to keep with with other controls and helpers.</p>
            <code>const gui = new GUI()</code>
            <p>To add specific controls we need to add the following lines after the scene content - because the objects in the scene are references in the controls. We're adding the slider to change the horizontal position of the cube and two color pickers. There are plenty of other options in the lil-gui documentation.</p>
            <code>
                <pre>
gui.add(cube.position, 'x').min(-5).max(5).step(0.1).name('Cube Position X')
gui.addColor(cube.material, 'color').name('Cube Color')
gui.addColor(plane.material, 'color').name('Plane Color')                    
                </pre>
            </code>
        </li>
    </ol>
</body>
</html>